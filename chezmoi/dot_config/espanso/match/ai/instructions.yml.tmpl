---
matches:
  - trigger: "ai11"
    replace: "{{ onepasswordRead .secrets.ai_help.one }}"
  - trigger: "ai12"
    replace: "{{ onepasswordRead .secrets.ai_help.two }}"
  - trigger: "ai13"
    replace: "{{ onepasswordRead .secrets.ai_help.three }}"
  - trigger: "ai14"
    replace: "{{ onepasswordRead .secrets.ai_help.four }}"
  - trigger: "ai15"
    replace: "{{ onepasswordRead .secrets.ai_help.five }}"
  - trigger: "ai22"
    replace: |
      Please pay attention to the text below as a limit to answer the questions above.


      > Conceptual Explanations Only
      **Purpose:**
      This mode is designed to provide *purely conceptual explanations* in the context of software development. The AI should focus on theories, principles, methodologies, or reasoning steps without any mention of code, syntax, or pseudocode. The emphasis is on *understanding the "why" and "how"* behind problems, features, bugs, or improvements.


      **Guidelines:**
        - Do not provide code snippets, pseudocode, or syntax hints.
        - Structure the response with headings, bullet points, and ordered steps.
        - Focus on concepts such as architecture patterns, debugging workflows, performance considerations, or best practices.
        - Emphasize the underlying thought process rather than implementation.


      **Example Style:**
        - Explain what a race condition is, why it happens, and the common strategies to prevent it (without showing actual locking code).
        - Describe the lifecycle of authentication in web apps conceptually (request, validation, session/token lifecycle).
        - Break down the steps of implementing a checkout flow conceptually (cart state, inventory validation, payment processing).
  - trigger: "ai23"
    replace: "Please pay attention to the text below as a limit to answer the questions above.\n\n> Conceptual Explanations + Syntax-Level References\n**Purpose:**  \nThis mode provides conceptual explanations with **references to programming language features or framework/library constructs** that act as signposts. These references should guide the user toward relevant tools without providing a direct implementation.\n\n**Guidelines:**  \n- Do not include full code blocks or pseudocode.  \n- References may include:  \n  - Built-in language features (e.g., JavaScript: `Array.filter`, `Promise.all`; Go: `fmt.Sprintf`).  \n  - Framework hooks, lifecycle methods, or utilities (e.g., React’s `useState`, `useEffect`; Express middleware; Prisma migrations).  \n- The references should help the user connect conceptual understanding to the tools provided by their stack.  \n- Use structured explanations with headings, numbered steps, and clear reasoning.  \n\n**Example Style:**  \n- While explaining filtering logic in a list, mention that `Array.filter` or `Array.map` is typically used.  \n- In debugging React state updates, point to `useState` and `useEffect` as relevant concepts.  \n- For handling authentication in a backend, reference Express middleware or JWT verification methods conceptually.  \n- When discussing performance improvements in databases, point to indexes or query optimizers as relevant constructs.\n"
  - trigger: "ai24"
    replace: "Please pay attention to the text below as a limit to answer the questions above.\n\n> Conceptual Explanations + Neutral/Analogous Code Examples\n**Purpose:**  \nThis mode combines conceptual explanations with **neutral or simplified code examples** that illustrate the principle in a safe, generic context. The code is never meant to be copied directly into the user’s project but serves as a teaching example. The AI should always explain why the example is relevant and how it could be adapted to the user’s situation.\n\n**Guidelines:**  \n- Begin with a conceptual explanation of the issue, feature, or improvement.  \n- Follow with a simplified code example in a different or generic context.  \n- Always explain:  \n  1. Why this example demonstrates the principle.  \n  2. How the same principle could be applied in the user’s project.  \n- Keep the examples educational, not project-specific.  \n\n**Example Style:**  \n- When explaining immutability in state management, show a simple counter app where state is updated with a new array instead of mutating it. Then explain how this principle applies to a React cart feature.  \n- When describing error handling, use a generic API fetch example, then explain how similar patterns could prevent bugs in the user’s authentication logic.  \n- When teaching about modular design, show a toy function split into smaller functions before explaining how this idea improves maintainability in real-world microservices.\n"
  - trigger: "ai25"
    replace: "Please pay attention to the text below as a limit to answer the questions above.\n\n> Direct Implementation in User's Context\n**Purpose:**  \nThis is the most practical mode. The AI provides **direct, working implementation code** tailored to the user’s software project. It should also explain the reasoning behind each part, highlight design considerations, and suggest best practices or alternatives.\n\n**Guidelines:**  \n- Write functional code that directly addresses the user’s request (feature, bug fix, refactor, or improvement).  \n- Provide explanations alongside the code: what each part does, why it’s needed, and how it integrates with the project.  \n- Highlight design considerations: scalability, maintainability, readability, performance, and security.  \n- Suggest possible improvements or alternatives (e.g., \"Alternatively, you could use X library for more flexibility\").  \n- Organize the answer into clear sections:  \n  1. Code snippet  \n  2. Explanation of code logic  \n  3. Design trade-offs and possible improvements  \n\n**Example Style:**  \n- Implement a React cart feature where users can add, remove, and update quantities, explaining why `useState` and `useReducer` might be chosen.  \n- Provide a bug fix for a failing SQL query, explaining why a JOIN is required instead of a nested subquery.  \n- Refactor an existing function into smaller, testable modules, with explanations of how this improves maintainability.  \n- Implement an authentication system with refresh/access tokens, including reasoning about token rotation and security considerations.\n"
